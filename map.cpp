#include <string.h> //For memset()

#include "math.cpp"


const uint16_t MAP_W = 512, MAP_H = 512;
const uint32_t MAP_A = MAP_W * MAP_H;
uint16_t map[MAP_W][MAP_H]; //00000000-00000000 - 00 luminosity, 0 animated, 000 frame, 0000 sprite, 00 biome

//Consonants
const uint8_t GEN_ISLANDS = 16;
const uint16_t GEN_ISLAND_RAD_MIN = 64;
const uint16_t GEN_ISLAND_RAD_MAX = 128;
const uint8_t GEN_ISLAND_RES = 4; //'resolution' of an island - how many blobs make it up
const uint8_t GEN_VILLAGES = 32;
const uint16_t GEN_VILLAGE_RAD_MIN = 16;
const uint16_t GEN_VILLAGE_RAD_MAX = 32;

uint8_t getBiome (uint16_t m) { return m & 0x03; }
void setBiome (uint16_t x, uint16_t y, uint8_t b) { if (x > 0 && x < MAP_W && y > 0 && y < MAP_H) {
    map[x][y] = (map[x][y] & 0xFFFC) | b;
} }
uint8_t getSprite (uint16_t m) { return (m & 0x3C) >> 2; }
void setSprite (uint16_t x, uint16_t y, uint8_t s) { if (x > 0 && x < MAP_W && y > 0 && y < MAP_H) {
    map[x][y] = (map[x][y] & 0xFFC3) | (s << 2);
} }
uint8_t getFrame (uint16_t m) { return (m & 0x1C0) >> 6; }
void setFrame (uint16_t x, uint16_t y, uint8_t f) { if (x > 0 && x < MAP_W && y > 0 && y < MAP_H) {
    map[x][y] = (map[x][y] & 0xFE3F) | (f << 6);
} }
bool getAnimated (uint16_t m) { return (m & 0x200) >> 9; }
void setAnimated (uint16_t x, uint16_t y, bool a) { if (x > 0 && x < MAP_W && y > 0 && y < MAP_H) {
    map[x][y] = (map[x][y] & 0xFDFF) | (a << 9);
} }
uint8_t getLux (uint16_t m) { return (m & 0xC00) >> 10; }
void setLux (uint16_t x, uint16_t y, uint8_t l, bool append = false) { if (x > 0 && x < MAP_W && y > 0 && y < MAP_H) {
    if (append) { if (getLux(map[x][y]) > l) { return; } }
    map[x][y] = (map[x][y] & 0xF3FF) | (l << 10);
} }

bool isFoliage (uint8_t sprite_code)
{
    switch (sprite_code) {
        case 4: case 5: return true;
        default: return false;
    }
}


void genMap ()
{
  //Set map to water
    memset(map, 3, sizeof map);
  //Generate islands
  //Generated by randomly placing differently sized circles (blobs) in a group
    for (uint8_t i = 0; i < GEN_ISLANDS; ++i) { //For each island
      //Calc island size and pos
        const uint16_t island_radius = ri(GEN_ISLAND_RAD_MIN, GEN_ISLAND_RAD_MAX);
        uint16_t island_X, island_Y;
        random_coord(MAP_W, MAP_H, island_X, island_Y);
      //Calc blob size and pos
        uint16_t blob_X = island_X + ri(island_radius / 2, island_radius);
        uint16_t blob_Y = island_Y + ri(island_radius / 2, island_radius);

        for (uint8_t b = 0; b < GEN_ISLAND_RES; ++b) { //For each blob in the island
            uint16_t blob_X = island_X + ri(0, island_radius * 2);
            uint16_t blob_Y = island_Y + ri(0, island_radius * 2);
          //Go through all angles from 0 to 2 * PI radians, in an ever-smaller circle (size), to fill the blob
            float size = 1.0;
            const float step = .005;
            while (size > step) {
                float r = size * island_radius;
                for (float ang = 0; ang < 6.28; ang += .01) {
                    uint16_t x = blob_X + r * sinf(ang);
                    uint16_t y = blob_Y + r * cosf(ang);
                  //Place some land there
                    setBiome(x, y, 1);
                }
                size -= step;
            }
        }
    }
  //Generate villages
    for (uint8_t v = 0; v < GEN_VILLAGES; ++v) { //For each village
      //Calc island size and pos
        const uint16_t village_radius = ri(GEN_VILLAGE_RAD_MIN, GEN_VILLAGE_RAD_MAX);
        uint16_t village_X, village_Y;
        do {
            random_coord(MAP_W, MAP_H, village_X, village_Y);
        } while (getBiome(map[village_X][village_Y]) == 3);
      //Go through all angles from 0 to 2 * PI radians, in an ever-smaller circle (size), to fill the village biome
        float size = 1.0;
        const float step = .005;
        while (size > step) {
            float r = size * village_radius;
            for (float ang = 0; ang < 6.28; ang += .01) {
                uint16_t x = village_X + r * sinf(ang);
                uint16_t y = village_Y + r * cosf(ang);
                setBiome(x, y, 0);
            }
            size -= step;
        }
      //Go through all angles and add wall of crates
        for (float ang = 0; ang < 6.28; ang += .01) {
            uint16_t x = village_X + village_radius * sinf(ang);
            uint16_t y = village_Y + village_radius * cosf(ang);
            setSprite(x, y, 2);
        }
        size -= step;
    }
  //En-masse
    for (uint16_t y = 1; y < MAP_H - 1; ++y) {
        for (uint16_t x = 1; x < MAP_W - 1; ++x) {
          //Set animation properties (idk why I even have to do this)
            setFrame(x, y, 0);
            setAnimated(x, y, false);
          //Remove all brick walls surrounded by stone biome (where village blobs have overlapped)
            if (getSprite(map[x][y]) == 2 && !getBiome(map[x+1][y]) && !getBiome(map[x-1][y]) && !getBiome(map[x][y+1]) && !getBiome(map[x][y-1])) {
                setSprite(x, y, 0);
            }
            uint8_t biome_code = getBiome(map[x][y]);
          //Add random fireplace and luminosity on stone
            if (!biome_code && !getSprite(map[x][y]) && rb(.01)) {
                setSprite(x, y, 3);
                setAnimated(x, y, true);
                setLux(x+0,y+0,3, true);
                setLux(x+1,y+0,2, true);
                setLux(x+2,y+0,1, true);
                setLux(x-1,y+0,2, true);
                setLux(x-2,y+0,1, true);
                setLux(x+0,y+1,2, true);
                setLux(x+1,y+1,2, true);
                setLux(x+2,y+1,1, true);
                setLux(x-1,y+1,2, true);
                setLux(x-2,y+1,1, true);
                setLux(x+0,y+2,1, true);
                setLux(x+1,y+2,1, true);
                setLux(x-1,y+2,1, true);
                setLux(x+0,y-1,2, true);
                setLux(x+1,y-1,2, true);
                setLux(x+2,y-1,1, true);
                setLux(x-1,y-1,2, true);
                setLux(x-2,y-1,1, true);
                setLux(x+0,y-2,1, true);
                setLux(x+1,y-2,1, true);
                setLux(x-1,y-2,1, true);
          //Add random foliage
            } else if (biome_code == 1) {
                if (rb(0.2)) {
                    setSprite(x, y, 4);
                    //setAnimated(x, y, true);
                } else if (rb(0.3)) {
                    setSprite(x, y, 5);
                    //setAnimated(x, y, true);
                }
            }
        }
    }
}
